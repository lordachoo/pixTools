#!/usr/bin/env python3
"""
SaltStack State Visualizer

This script parses SaltStack states in a given directory and outputs an ASCII diagram
or graphical visualization showing the relationships between states, roles, systemd units,
and their dependencies.
"""

import os
import sys
import re
import subprocess
import argparse
import yaml
import graphviz
from collections import defaultdict

class SaltStateVisualizer:
    def __init__(self, salt_path):
        self.salt_path = salt_path
        self.states = []
        self.roles = defaultdict(list)
        self.systemd_units = defaultdict(set)
        self.includes = defaultdict(set)
        self.dependencies = defaultdict(list)
        self.role_dependencies = defaultdict(list)
        self.pillar_dependencies = defaultdict(set)

    def find_whole_states(self):
        """Find all directories containing init.sls files (whole states)"""
        try:
            cmd = f"find {self.salt_path} -name 'init.sls' -printf '%h\n' | xargs -n1 basename"
            result = subprocess.run(cmd, shell=True, check=True, text=True, capture_output=True)
            unique_states = {state.strip() for state in result.stdout.split('\n') if state.strip()}
            self.states = sorted(list(unique_states))  # Convert back to sorted list for consistent ordering
            return self.states
        except subprocess.CalledProcessError as e:
            print(f"Error finding whole states: {e}", file=sys.stderr)
            return []

    def parse_state_files(self):
        """Parse all state files to extract roles and systemd units"""
        for state in self.states:
            state_dir = os.path.join(self.salt_path, state)
            
            # Parse init.sls for includes
            init_file = os.path.join(state_dir, 'init.sls')
            if os.path.exists(init_file):
                self._parse_includes(init_file, state)
            
            # Parse all .sls files in the state directory
            for root, _, files in os.walk(state_dir):
                for file in files:
                    if file.endswith('.sls'):
                        file_path = os.path.join(root, file)
                        self._parse_file(file_path, state)

    def _parse_includes(self, file_path, state):
        """Parse include statements from a state file"""
        try:
            with open(file_path, 'r') as f:
                content = f.read()
                
            # Pre-process content to standardize templated variables
            content = re.sub(r'@\{\{\s*([^\}]+)\s*\}\}', r'@<\1>', content)
            # Make sure to standardize any remaining templated variables
            content = re.sub(r'\{\{\s*([^\}]+)\s*\}\}', r'<\1>', content)
                
            # Find include statements
            include_match = re.search(r'include:\s*\n((?:\s*-\s*.*\n)+)', content)
            if include_match:
                includes_block = include_match.group(1)
                includes = re.findall(r'-\s*(.*)', includes_block)
                
                includes_set = set(include.strip() for include in includes)
                includes_set = {include if not include.startswith('.') else f"{state}{include}" for include in includes_set}
                self.includes[state] = self.includes[state].union(includes_set)
        except Exception as e:
            print(f"Error parsing includes in {file_path}: {e}", file=sys.stderr)

    def _parse_file(self, file_path, state):
        """Parse a state file for roles and systemd units"""
        try:
            with open(file_path, 'r') as f:
                content = f.read()
            
            # Try to parse as YAML if possible
            try:
                # Skip the first part if it's a comment block
                yaml_content = re.sub(r'^#.*?(?=^[^#])', '', content, flags=re.DOTALL | re.MULTILINE)
                data = yaml.safe_load(yaml_content)
                if data and isinstance(data, dict):
                    self._extract_from_yaml(data, state)
            except Exception:
                # Fallback to regex parsing if YAML parsing fails
                pass
            
            # First, find all role patterns in the file
            role_pattern1 = r"salt\['pixpillar\.nodehasrole'\]\('([^']+)'\)"
            role_pattern2 = r"salt\.pixpillar\.nodehasrole\('([^']+)'\)"
            
            # Find complex conditional role dependencies
            # This regex looks for conditional blocks that use nodehasrole
            conditional_blocks = re.findall(r'\{%-?\s*if.*?\{%-?\s*endif\s*-?%\}', content, re.DOTALL)
            for block in conditional_blocks:
                # Extract roles from conditional blocks
                role_matches1 = re.findall(role_pattern1, block)
                role_matches2 = re.findall(role_pattern2, block)
                conditional_roles = set(role_matches1 + role_matches2)
                for role in conditional_roles:
                    if role not in self.role_dependencies[state]:
                        self.role_dependencies[state].append(role)
            
            # Find direct role assignments (outside of conditional blocks)
            # We'll process the content line by line to better distinguish
            # between conditional and non-conditional roles
            lines = content.split('\n')
            for i, line in enumerate(lines):
                # Skip lines that are part of conditional blocks
                if '{%' in line and 'if' in line:
                    continue
                if '%}' in line and 'endif' in line:
                    continue
                    
                # Look for direct role assignments
                role_matches1 = re.findall(role_pattern1, line)
                role_matches2 = re.findall(role_pattern2, line)
                direct_roles = set(role_matches1 + role_matches2)
                for role in direct_roles:
                    # Avoid adding roles that are already in role dependencies
                    if role not in self.roles[state] and role not in self.role_dependencies[state]:
                        self.roles[state].append(role)
            
            # Find pillar dependencies
            # Look for patterns like: salt.pillar.get('pillar_path')
            pillar_pattern = r"salt\.pillar\.get\('([^']+)'\)"
            pillar_matches = re.findall(pillar_pattern, content)
            for pillar in pillar_matches:
                self.pillar_dependencies[state].add(pillar)
            
            # Also look for more complex pillar patterns with default values
            pillar_with_default_pattern = r"salt\.pillar\.get\('([^']+)'\s*,\s*[^\)]+\)"
            pillar_with_default_matches = re.findall(pillar_with_default_pattern, content)
            for pillar in pillar_with_default_matches:
                self.pillar_dependencies[state].add(pillar)
            
            # Find systemd units - multiple patterns
            # Pattern 1: Standard service.running with name
            service_matches = re.findall(r'service\.running:\s*\n\s*-\s*name:\s*([^\n]+)', content)
            for service in service_matches:
                service = service.strip()
                self.systemd_units[state].add(service)
            
            # Pattern 2: Direct service.running declaration
            direct_service_matches = re.findall(r'\w+:\s*\n\s+service\.running:\s*\n\s*-\s*name:\s*([^\n]+)', content)
            for service in direct_service_matches:
                service = service.strip()
                self.systemd_units[state].add(service)
            
            # Pattern 3: systemd.* states
            systemd_matches = re.findall(r'systemd\.([a-z]+):\s*\n\s*-\s*name:\s*([^\n]+)', content)
            for _, service in systemd_matches:
                service = service.strip()
                self.systemd_units[state].add(service)
                    
            # Pattern 4: service.disabled
            disabled_service_matches = re.findall(r'service\.disabled:\s*\n\s*-\s*name:\s*([^\n]+)', content)
            for service in disabled_service_matches:
                service = service.strip()
                self.systemd_units[state].add(service)
                    
            # Pattern 5: Direct service name in ID with service.running
            id_service_matches = re.findall(r'([\w@\.-]+):\s*\n\s+service\.running:', content)
            for service in id_service_matches:
                if service.endswith('.service') or '@' in service or service.endswith('.timer'):
                    service = service.strip()
                    self.systemd_units[state].add(service)
            
            # Pattern 6: Look for enable/disable service statements
            enable_service_matches = re.findall(r'enable\s+([\w@\.-]+):', content)
            for service in enable_service_matches:
                if service.endswith('.service') or '@' in service or service.endswith('.timer'):
                    service = service.strip()
                    self.systemd_units[state].add(service)
            
            # Pattern 7: Look for specific timer patterns
            timer_matches = re.findall(r'ap-[\w-]+@[\w\.-]+\.timer', content)
            for service in timer_matches:
                service = service.strip()
                self.systemd_units[state].add(service)
                    
            # Pattern 8: Look for templated service names
            templated_service_matches = re.findall(r'([\w@\.-]+@\{\{[^\}]+\}\}\.(timer|service))', content)
            for service_match in templated_service_matches:
                if isinstance(service_match, tuple):
                    service = service_match[0]  # Extract the first element if it's a tuple
                else:
                    service = service_match
                service = service.strip()
                self.systemd_units[state].add(service)
                    
            # Pattern 9: Specifically look for ap-analytics timer pattern
            analytics_timer_matches = re.findall(r'ap-analytics@[^\s]+\.timer', content)
            for service in analytics_timer_matches:
                service = service.strip()
                self.systemd_units[state].add(service)
                    
            # Pattern 10: Look for timer/service patterns in enable/disable statements
            for line in content.split('\n'):
                if 'enable' in line or 'disable' in line:
                    if '.timer' in line or '.service' in line:
                        # Extract service name from the line
                        service_match = re.search(r'([\w@\.-]+\.(timer|service))', line)
                        if service_match:
                            service = service_match.group(1).strip()
                            self.systemd_units[state].add(service)
        except Exception as e:
            print(f"Error parsing file {file_path}: {e}", file=sys.stderr)
            
    def _extract_from_yaml(self, data, state):
        """Extract information from parsed YAML data"""
        for key, value in data.items():
            if isinstance(value, dict):
                # Check for service definitions
                if 'service' in value:
                    if isinstance(value['service'], list):
                        for item in value['service']:
                            if isinstance(item, dict) and 'name' in item:
                                service = item['name']
                                if service not in self.systemd_units[state]:
                                    self.systemd_units[state].append(service)
                    elif isinstance(value['service'], dict) and 'name' in value['service']:
                        service = value['service']['name']
                        if service not in self.systemd_units[state]:
                            self.systemd_units[state].append(service)
                
                # Recursively check nested dictionaries
                self._extract_from_yaml(value, state)

    def generate_ascii_diagram(self, show_pillars=True, show_roles=True):
        """Generate ASCII diagram of states, roles, and systemd units"""
        diagram = []
        diagram.append("=" * 80)
        diagram.append("SaltStack State Visualization")
        diagram.append("=" * 80)
        diagram.append("")
        
        # Generate diagram for each state
        for state in sorted(self.states):
            diagram.append(f"State: {state}")
            diagram.append("-" * 40)
            
            # Add roles
            if state in self.roles and self.roles[state]:
                diagram.append("  Roles:")
                roles = sorted(self.roles[state])
                for i, role in enumerate(roles):
                    if i == len(roles) - 1:
                        diagram.append(f"    └── {role}")
                    else:
                        diagram.append(f"    ├── {role}")
            
            # Add role dependencies if enabled
            if show_roles and state in self.role_dependencies and self.role_dependencies[state]:
                # Filter out roles that are already in the roles list to avoid duplicates
                role_deps = [r for r in self.role_dependencies[state] if r not in self.roles.get(state, [])]
                if role_deps:
                    diagram.append("  Role Dependencies:")
                    role_deps = sorted(role_deps)
                    for i, role in enumerate(role_deps):
                        if i == len(role_deps) - 1:
                            diagram.append(f"    └── {role}")
                        else:
                            diagram.append(f"    ├── {role}")
            
            # Add pillar dependencies if enabled
            if show_pillars and state in self.pillar_dependencies and self.pillar_dependencies[state]:
                diagram.append("  Pillar Dependencies:")
                pillar_deps = sorted(list(self.pillar_dependencies[state]))
                for i, pillar in enumerate(pillar_deps):
                    if i == len(pillar_deps) - 1:
                        diagram.append(f"    └── {pillar}")
                    else:
                        diagram.append(f"    ├── {pillar}")
            
            # Add systemd units
            if state in self.systemd_units and self.systemd_units[state]:
                diagram.append("  Systemd Units:")
                units = sorted(list(self.systemd_units[state]))
                for i, unit in enumerate(units):
                    if i == len(units) - 1:
                        diagram.append(f"    └── {unit}")
                    else:
                        diagram.append(f"    ├── {unit}")
            
            # Add dependencies (includes)
            if state in self.includes and self.includes[state]:
                diagram.append("  Dependencies:")
                includes = sorted(list(self.includes[state]))
                for i, include in enumerate(includes):
                    if i == len(includes) - 1:
                        diagram.append(f"    └── {include}")
                    else:
                        diagram.append(f"    ├── {include}")
            
            diagram.append("")
        
        # Add summary statistics
        # Count unique roles
        all_roles = set()
        for roles in self.roles.values():
            all_roles.update(roles)
        
        # Count unique role dependencies
        all_role_deps = set()
        for deps in self.role_dependencies.values():
            all_role_deps.update(deps)
        
        # Count unique pillar dependencies
        all_pillar_deps = set()
        for deps in self.pillar_dependencies.values():
            all_pillar_deps.update(deps)
        
        # Count unique systemd units
        all_systemd_units = set()
        for units in self.systemd_units.values():
            all_systemd_units.update(units)
        
        diagram.append("=" * 80)
        diagram.append(f"Total States: {len(self.states)}")
        diagram.append(f"Total Roles: {len(all_roles)}")
        if show_roles:
            diagram.append(f"Total Role Dependencies: {len(all_role_deps)}")
        if show_pillars:
            diagram.append(f"Total Pillar Dependencies: {len(all_pillar_deps)}")
        diagram.append(f"Total Systemd Units: {len(all_systemd_units)}")
        diagram.append("=" * 80)
        
        return "\n".join(diagram)
        if show_pillars and state in self.pillar_dependencies and self.pillar_dependencies[state]:
            diagram.append("  Pillar Dependencies:")
            pillar_deps = sorted(list(self.pillar_dependencies[state]))
            for i, pillar in enumerate(pillar_deps):
                if i == len(pillar_deps) - 1:
                    diagram.append(f"    └── {pillar}")
                else:
                    diagram.append(f"    ├── {pillar}")

        # Add systemd units
        if state in self.systemd_units and self.systemd_units[state]:
            diagram.append("  Systemd Units:")
            units = sorted(list(self.systemd_units[state]))
            for i, unit in enumerate(units):
                if i == len(units) - 1:
                    diagram.append(f"    └── {unit}")
                else:
                    diagram.append(f"    ├── {unit}")

        # Add dependencies (includes)
        if state in self.includes and self.includes[state]:
            diagram.append("  Dependencies:")
            includes = sorted(list(self.includes[state]))
            for i, include in enumerate(includes):
                if i == len(includes) - 1:
                    diagram.append(f"    └── {include}")
                else:
                    diagram.append(f"    ├── {include}")

        diagram.append("")

    # Add summary statistics
    # Count unique roles
    all_roles = set()
    for roles in self.roles.values():
        all_roles.update(roles)

    # Count unique role dependencies
    all_role_deps = set()
    for deps in self.role_dependencies.values():
        all_role_deps.update(deps)

    # Count unique pillar dependencies
    all_pillar_deps = set()
    for deps in self.pillar_dependencies.values():
        all_pillar_deps.update(deps)

    # Count unique systemd units
    all_systemd_units = set()
    for units in self.systemd_units.values():
        all_systemd_units.update(units)

    diagram.append("=" * 80)
    diagram.append(f"Total States: {len(self.states)}")


    def generate_graphviz(self, output_file=None, show_pillars=True, show_roles=True, show_systemd=True, format='svg'):
        """Generate a graphical visualization using graphviz

        Args:
            output_file: Path to save the output file (without extension)
            show_pillars: Whether to show pillar dependencies
            show_roles: Whether to show role dependencies
            show_systemd: Whether to show systemd units
            format: Output format (svg, png, pdf, etc.)

        Returns:
            Path to the generated file
        """
        # Create a new directed graph
        dot = graphviz.Digraph(comment='SaltStack State Visualization', format=format)
        dot.attr(rankdir='LR', size='11,8', dpi='300')
        dot.attr('node', shape='box', style='filled', fontname='Arial', fontsize='10')

        # Define node styles
        state_attrs = {'fillcolor': '#ADD8E6', 'style': 'filled'}  # Light blue
        role_attrs = {'fillcolor': '#90EE90', 'shape': 'ellipse', 'style': 'filled'}  # Light green
        pillar_attrs = {'fillcolor': '#FFFFE0', 'shape': 'diamond', 'style': 'filled'}  # Light yellow
        systemd_attrs = {'fillcolor': '#FFB6C1', 'shape': 'box', 'style': 'filled'}  # Light pink

        # Add states as nodes
        for state in sorted(self.states):
            state_id = f"state_{state}"
            dot.node(state_id, state, **state_attrs)

            # Add role dependencies
            if show_roles and state in self.role_dependencies and self.role_dependencies[state]:
                for role in sorted(self.role_dependencies[state]):
                    role_id = f"role_{role}"
                    # Check if the node already exists to avoid duplicates
                    if role_id not in [n for n in dot.body if isinstance(n, str) and role_id in n]:
                        dot.node(role_id, role, **role_attrs)
                    dot.edge(state_id, role_id, label="requires role")

            # Add pillar dependencies
            if show_pillars and state in self.pillar_dependencies and self.pillar_dependencies[state]:
                for pillar in sorted(list(self.pillar_dependencies[state])):
                    pillar_id = f"pillar_{pillar}"
                    # Check if the node already exists to avoid duplicates
                    if pillar_id not in [n for n in dot.body if isinstance(n, str) and pillar_id in n]:
                        dot.node(pillar_id, pillar, **pillar_attrs)
                    dot.edge(state_id, pillar_id, label="uses pillar")

            # Add systemd units
            if show_systemd and state in self.systemd_units and self.systemd_units[state]:
                for unit in sorted(list(self.systemd_units[state])):
                    unit_id = f"systemd_{unit}"
                    # Check if the node already exists to avoid duplicates
                    if unit_id not in [n for n in dot.body if isinstance(n, str) and unit_id in n]:
                        dot.node(unit_id, unit, **systemd_attrs)
                    dot.edge(state_id, unit_id, label="manages")

            # Add dependencies between states
            if state in self.includes and self.includes[state]:
                for dep in sorted(list(self.includes[state])):
                    # Extract the base state name from the dependency
                    base_dep = dep.split('.')[0]
                    if base_dep in self.states:
                        dep_id = f"state_{base_dep}"
                        dot.edge(state_id, dep_id, label="includes")

        # Render the graph
        if output_file:
            return dot.render(output_file, cleanup=True)
        else:
            return dot.render(cleanup=True)

def main():
    parser = argparse.ArgumentParser(description='SaltStack State Visualizer')
    parser.add_argument('salt_path', help='Path to the SaltStack states directory')
    parser.add_argument('-o', '--output', help='Output file path (default: stdout)')
    parser.add_argument('-p', '--pillars', action='store_true', help='Include pillar dependencies in the output')
    parser.add_argument('-r', '--roles', action='store_true', help='Include role dependencies in the output')
    parser.add_argument('--no-pillars', action='store_true', help='Exclude pillar dependencies from the output')
    parser.add_argument('--no-roles', action='store_true', help='Exclude role dependencies from the output')
    parser.add_argument('--no-systemd', action='store_true', help='Exclude systemd units from the output')
    parser.add_argument('-g', '--graphical', action='store_true', help='Generate graphical output (SVG) instead of ASCII')
    parser.add_argument('-f', '--format', default='svg', help='Output format for graphical output (svg, png, pdf, etc.)')
    args = parser.parse_args()
    
    salt_path = args.salt_path
    if not os.path.isdir(salt_path):
        print(f"Error: {salt_path} is not a directory", file=sys.stderr)
        sys.exit(1)
    
    visualizer = SaltStateVisualizer(salt_path)
    
    print(f"Finding whole states in {salt_path}...", file=sys.stderr)
    states = visualizer.find_whole_states()
    print(f"Found {len(states)} whole states", file=sys.stderr)
    
    print("Parsing state files...", file=sys.stderr)
    visualizer.parse_state_files()
    
    # Process command line flags
    show_pillars = not args.no_pillars
    show_roles = not args.no_roles
    show_systemd = not args.no_systemd
    
    # Determine output type and generate appropriate visualization
    if args.graphical:
        output_file = args.output
        if output_file and '.' in output_file:
            # Strip extension if present as graphviz will add it
            output_file = os.path.splitext(output_file)[0]
            
        print(f"Generating graphical visualization in {args.format} format...", file=sys.stderr)
        output_path = visualizer.generate_graphviz(
            output_file=output_file,
            show_pillars=show_pillars,
            show_roles=show_roles,
            show_systemd=show_systemd,
            format=args.format
        )
        print(f"Graphical visualization written to {output_path}", file=sys.stderr)
    else:
        print("Generating ASCII diagram...", file=sys.stderr)
        diagram = visualizer.generate_ascii_diagram(show_pillars=show_pillars, show_roles=show_roles)
        
        if args.output:
            try:
                with open(args.output, 'w') as f:
                    f.write(diagram)
                print(f"Diagram written to {args.output}", file=sys.stderr)
            except Exception as e:
                print(f"Error writing to {args.output}: {e}", file=sys.stderr)
                sys.exit(1)
        else:
            print(diagram)

if __name__ == "__main__":
    main()
