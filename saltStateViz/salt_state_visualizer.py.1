#!/usr/bin/env python3
"""
SaltStack State Visualizer

This script parses SaltStack states in a given directory and outputs an ASCII diagram
showing the relationships between states, roles, and systemd units.
"""

import os
import sys
import re
import subprocess
import argparse
import yaml
from collections import defaultdict

class SaltStateVisualizer:
    def __init__(self, salt_path):
        self.salt_path = salt_path
        self.states = []
        self.roles = defaultdict(list)
        self.systemd_units = defaultdict(set)
        self.includes = defaultdict(set)
        self.dependencies = defaultdict(list)
        self.role_dependencies = defaultdict(list)
        self.pillar_dependencies = defaultdict(set)

    def find_whole_states(self):
        """Find all directories containing init.sls files (whole states)"""
        try:
            cmd = f"find {self.salt_path} -name 'init.sls' -printf '%h\n' | xargs -n1 basename"
            result = subprocess.run(cmd, shell=True, check=True, text=True, capture_output=True)
            unique_states = {state.strip() for state in result.stdout.split('\n') if state.strip()}
            self.states = sorted(list(unique_states))  # Convert back to sorted list for consistent ordering
            return self.states
        except subprocess.CalledProcessError as e:
            print(f"Error finding whole states: {e}", file=sys.stderr)
            return []

    def parse_state_files(self):
        """Parse all state files to extract roles and systemd units"""
        for state in self.states:
            state_dir = os.path.join(self.salt_path, state)
            
            # Parse init.sls for includes
            init_file = os.path.join(state_dir, 'init.sls')
            if os.path.exists(init_file):
                self._parse_includes(init_file, state)
            
            # Parse all .sls files in the state directory
            for root, _, files in os.walk(state_dir):
                for file in files:
                    if file.endswith('.sls'):
                        file_path = os.path.join(root, file)
                        self._parse_file(file_path, state)

    def _parse_includes(self, file_path, state):
        """Parse include statements from a state file"""
        try:
            with open(file_path, 'r') as f:
                content = f.read()
                
            # Pre-process content to standardize templated variables
            content = re.sub(r'@\{\{\s*([^\}]+)\s*\}\}', r'@<\1>', content)
            # Make sure to standardize any remaining templated variables
            content = re.sub(r'\{\{\s*([^\}]+)\s*\}\}', r'<\1>', content)
                
            # Find include statements
            include_match = re.search(r'include:\s*\n((?:\s*-\s*.*\n)+)', content)
            if include_match:
                includes_block = include_match.group(1)
                includes = re.findall(r'-\s*(.*)', includes_block)
                
                includes_set = set(include.strip() for include in includes)
                includes_set = {include if not include.startswith('.') else f"{state}{include}" for include in includes_set}
                self.includes[state] = self.includes[state].union(includes_set)
        except Exception as e:
            print(f"Error parsing includes in {file_path}: {e}", file=sys.stderr)

    def _parse_file(self, file_path, state):
        """Parse a state file for roles and systemd units"""
        try:
            with open(file_path, 'r') as f:
                content = f.read()
            
            # Try to parse as YAML if possible
            try:
                # Skip the first part if it's a comment block
                yaml_content = re.sub(r'^#.*?(?=^[^#])', '', content, flags=re.DOTALL | re.MULTILINE)
                data = yaml.safe_load(yaml_content)
                if data and isinstance(data, dict):
                    self._extract_from_yaml(data, state)
            except Exception:
                # Fallback to regex parsing if YAML parsing fails
                pass
            
            # First, find all role patterns in the file
            role_pattern1 = r"salt\['pixpillar\.nodehasrole'\]\('([^']+)'\)"
            role_pattern2 = r"salt\.pixpillar\.nodehasrole\('([^']+)'\)"
            
            # Find complex conditional role dependencies
            # This regex looks for conditional blocks that use nodehasrole
            conditional_blocks = re.findall(r'\{%-?\s*if.*?\{%-?\s*endif\s*-?%\}', content, re.DOTALL)
            for block in conditional_blocks:
                # Extract roles from conditional blocks
                role_matches1 = re.findall(role_pattern1, block)
                role_matches2 = re.findall(role_pattern2, block)
                conditional_roles = set(role_matches1 + role_matches2)
                for role in conditional_roles:
                    if role not in self.role_dependencies[state]:
                        self.role_dependencies[state].append(role)
            
            # Find direct role assignments (outside of conditional blocks)
            # We'll process the content line by line to better distinguish
            # between conditional and non-conditional roles
            lines = content.split('\n')
            for i, line in enumerate(lines):
                # Skip lines that are part of conditional blocks
                if '{%' in line and 'if' in line:
                    continue
                if '%}' in line and 'endif' in line:
                    continue
                    
                # Look for direct role assignments
                role_matches1 = re.findall(role_pattern1, line)
                role_matches2 = re.findall(role_pattern2, line)
                direct_roles = set(role_matches1 + role_matches2)
                for role in direct_roles:
                    # Avoid adding roles that are already in role dependencies
                    if role not in self.roles[state] and role not in self.role_dependencies[state]:
                        self.roles[state].append(role)
            
            # Find pillar dependencies
            # Look for patterns like: salt.pillar.get('pillar_path')
            pillar_pattern = r"salt\.pillar\.get\('([^']+)'\)"
            pillar_matches = re.findall(pillar_pattern, content)
            for pillar in pillar_matches:
                self.pillar_dependencies[state].add(pillar)
            
            # Also look for more complex pillar patterns with default values
            pillar_with_default_pattern = r"salt\.pillar\.get\('([^']+)'\s*,\s*[^\)]+\)"
            pillar_with_default_matches = re.findall(pillar_with_default_pattern, content)
            for pillar in pillar_with_default_matches:
                self.pillar_dependencies[state].add(pillar)
            
            # Find systemd units - multiple patterns
            # Pattern 1: Standard service.running with name
            service_matches = re.findall(r'service\.running:\s*\n\s*-\s*name:\s*([^\n]+)', content)
            for service in service_matches:
                service = service.strip()
                self.systemd_units[state].add(service)
            
            # Pattern 2: Direct service.running declaration
            direct_service_matches = re.findall(r'\w+:\s*\n\s+service\.running:\s*\n\s*-\s*name:\s*([^\n]+)', content)
            for service in direct_service_matches:
                service = service.strip()
                self.systemd_units[state].add(service)
            
            # Pattern 3: systemd.* states
            systemd_matches = re.findall(r'systemd\.([a-z]+):\s*\n\s*-\s*name:\s*([^\n]+)', content)
            for _, service in systemd_matches:
                service = service.strip()
                self.systemd_units[state].add(service)
                    
            # Pattern 4: service.disabled
            disabled_service_matches = re.findall(r'service\.disabled:\s*\n\s*-\s*name:\s*([^\n]+)', content)
            for service in disabled_service_matches:
                service = service.strip()
                self.systemd_units[state].add(service)
                    
            # Pattern 5: Direct service name in ID with service.running
            id_service_matches = re.findall(r'([\w@\.-]+):\s*\n\s+service\.running:', content)
            for service in id_service_matches:
                if service.endswith('.service') or '@' in service or service.endswith('.timer'):
                    service = service.strip()
                    self.systemd_units[state].add(service)
            
            # Pattern 6: Look for enable/disable service statements
            enable_service_matches = re.findall(r'enable\s+([\w@\.-]+):', content)
            for service in enable_service_matches:
                if service.endswith('.service') or '@' in service or service.endswith('.timer'):
                    service = service.strip()
                    self.systemd_units[state].add(service)
            
            # Pattern 7: Look for specific timer patterns
            timer_matches = re.findall(r'ap-[\w-]+@[\w\.-]+\.timer', content)
            for service in timer_matches:
                service = service.strip()
                self.systemd_units[state].add(service)
                    
            # Pattern 8: Look for templated service names
            templated_service_matches = re.findall(r'([\w@\.-]+@\{\{[^\}]+\}\}\.(timer|service))', content)
            for service_match in templated_service_matches:
                if isinstance(service_match, tuple):
                    service = service_match[0]  # Extract the first element if it's a tuple
                else:
                    service = service_match
                service = service.strip()
                self.systemd_units[state].add(service)
                    
            # Pattern 9: Specifically look for ap-analytics timer pattern
            analytics_timer_matches = re.findall(r'ap-analytics@[^\s]+\.timer', content)
            for service in analytics_timer_matches:
                service = service.strip()
                self.systemd_units[state].add(service)
                    
            # Pattern 10: Look for timer/service patterns in enable/disable statements
            for line in content.split('\n'):
                if 'enable' in line or 'disable' in line:
                    if '.timer' in line or '.service' in line:
                        # Extract service name from the line
                        service_match = re.search(r'([\w@\.-]+\.(timer|service))', line)
                        if service_match:
                            service = service_match.group(1).strip()
                            self.systemd_units[state].add(service)
        except Exception as e:
            print(f"Error parsing file {file_path}: {e}", file=sys.stderr)
            
    def _extract_from_yaml(self, data, state):
        """Extract information from parsed YAML data"""
        for key, value in data.items():
            if isinstance(value, dict):
                # Check for service definitions
                if 'service' in value:
                    if isinstance(value['service'], list):
                        for item in value['service']:
                            if isinstance(item, dict) and 'name' in item:
                                service = item['name']
                                if service not in self.systemd_units[state]:
                                    self.systemd_units[state].append(service)
                    elif isinstance(value['service'], dict) and 'name' in value['service']:
                        service = value['service']['name']
                        if service not in self.systemd_units[state]:
                            self.systemd_units[state].append(service)
                
                # Recursively check nested dictionaries
                self._extract_from_yaml(value, state)

    def generate_ascii_diagram(self, show_pillars=True, show_roles=True):
        """Generate ASCII diagram of states, roles, and systemd units"""
        diagram = []
        diagram.append("=" * 80)
        diagram.append("SaltStack State Visualization")
        diagram.append("=" * 80)
        diagram.append("")
        
        # Generate diagram for each state
        for state in sorted(self.states):
            diagram.append(f"State: {state}")
            diagram.append("-" * 40)
            
            # Add roles
            if state in self.roles and self.roles[state]:
                diagram.append("  Roles:")
                roles = sorted(self.roles[state])
                for i, role in enumerate(roles):
                    if i == len(roles) - 1:
                        diagram.append(f"    └── {role}")
                    else:
                        diagram.append(f"    ├── {role}")
            
            # Add role dependencies if enabled
            if show_roles and state in self.role_dependencies and self.role_dependencies[state]:
                # Filter out roles that are already in the roles list to avoid duplicates
                role_deps = [r for r in self.role_dependencies[state] if r not in self.roles[state]]
                if role_deps:
                    diagram.append("  Role Dependencies:")
                    role_deps = sorted(role_deps)
                    for i, role in enumerate(role_deps):
                        if i == len(role_deps) - 1:
                            diagram.append(f"    └── {role}")
                        else:
                            diagram.append(f"    ├── {role}")
            
            # Add pillar dependencies if enabled
            if show_pillars and state in self.pillar_dependencies and self.pillar_dependencies[state]:
                diagram.append("  Pillar Dependencies:")
                pillar_deps = sorted(self.pillar_dependencies[state])
                for i, pillar in enumerate(pillar_deps):
                    if i == len(pillar_deps) - 1:
                        diagram.append(f"    └── {pillar}")
                    else:
                        diagram.append(f"    ├── {pillar}")
            
            # Add systemd units
            if state in self.systemd_units and self.systemd_units[state]:
                diagram.append("  Systemd Units:")
                units = sorted(list(self.systemd_units[state]))
                for i, unit in enumerate(units):
                    if i == len(units) - 1:
                        diagram.append(f"    └── {unit}")
                    else:
                        diagram.append(f"    ├── {unit}")
            
            # Add dependencies (includes)
            if state in self.includes and self.includes[state]:
                diagram.append("  Dependencies:")
                includes = sorted(self.includes[state])
                for i, include in enumerate(includes):
                    if i == len(includes) - 1:
                        diagram.append(f"    └── {include}")
                    else:
                        diagram.append(f"    ├── {include}")
            
            diagram.append("")
        
        # Add summary statistics
        total_roles = sum(len(roles) for roles in self.roles.values())
        # Fix role dependency counting to properly handle each state's roles
        total_role_deps = 0
        for state, deps in self.role_dependencies.items():
            state_roles = self.roles.get(state, [])
            total_role_deps += len([r for r in deps if r not in state_roles])
        total_pillar_deps = sum(len(deps) for deps in self.pillar_dependencies.values())
        # Handle sets for systemd units
        total_units = sum(len(units) for units in self.systemd_units.values())
        
        diagram.append("=" * 80)
        diagram.append(f"Total States: {len(self.states)}")
        diagram.append(f"Total Roles: {total_roles}")
        if show_roles:
            diagram.append(f"Total Role Dependencies: {total_role_deps}")
        if show_pillars:
            diagram.append(f"Total Pillar Dependencies: {total_pillar_deps}")
        diagram.append(f"Total Systemd Units: {total_units}")
        diagram.append("=" * 80)
        
        return "\n".join(diagram)

def main():
    parser = argparse.ArgumentParser(description='SaltStack State Visualizer')
    parser.add_argument('salt_path', help='Path to the SaltStack states directory')
    parser.add_argument('-o', '--output', help='Output file path (default: stdout)')
    parser.add_argument('-p', '--pillars', action='store_true', help='Include pillar dependencies in the output')
    parser.add_argument('-r', '--roles', action='store_true', help='Include role dependencies in the output')
    parser.add_argument('--no-pillars', action='store_true', help='Exclude pillar dependencies from the output')
    parser.add_argument('--no-roles', action='store_true', help='Exclude role dependencies from the output')
    args = parser.parse_args()
    
    salt_path = args.salt_path
    if not os.path.isdir(salt_path):
        print(f"Error: {salt_path} is not a directory", file=sys.stderr)
        sys.exit(1)
    
    visualizer = SaltStateVisualizer(salt_path)
    
    print(f"Finding whole states in {salt_path}...", file=sys.stderr)
    states = visualizer.find_whole_states()
    print(f"Found {len(states)} whole states", file=sys.stderr)
    
    print("Parsing state files...", file=sys.stderr)
    visualizer.parse_state_files()
    
    # Process command line flags
    show_pillars = not args.no_pillars
    show_roles = not args.no_roles
    
    print("Generating ASCII diagram...", file=sys.stderr)
    diagram = visualizer.generate_ascii_diagram(show_pillars=show_pillars, show_roles=show_roles)
    
    if args.output:
        try:
            with open(args.output, 'w') as f:
                f.write(diagram)
            print(f"Diagram written to {args.output}", file=sys.stderr)
        except Exception as e:
            print(f"Error writing to {args.output}: {e}", file=sys.stderr)
            sys.exit(1)
    else:
        print(diagram)

if __name__ == "__main__":
    main()
